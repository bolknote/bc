/*
 * *****************************************************************************
 *
 * SPDX-License-Identifier: BSD-2-Clause
 *
 * Copyright (c) 2018-2025 Gavin D. Howard and contributors.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * *****************************************************************************
 *
 * The build package file.
 *
 */

/// The path to the safe install script.
SAFE_INSTALL: str = path.join(src_dir, "scripts/safe-install.sh");

/// The file mode for executables, as an argument to the safe install script.
EXEC_INSTALL_MODE: str = "-Dm755";

/// The file mode for man pages and other files, as an argument to the safe
/// install script.
MANPAGE_INSTALL_MODE: str = "-Dm644";

// Save this.
OS: str = platform.os;

DESTDIR: str = str(config["destdir"]);

EXECPREFIX: str = str(config["execprefix"]);
EXECSUFFIX: str = str(config["execsuffix"]);

/**
 * Generates the true executable name for the given base name.
 * @param name  The base name of the executable.
 * @return      The true name of the executable, including prefix, suffix, and
                extension.
 */
fn exe_name(name: str) -> str
{
	temp: str = EXECPREFIX +~ name +~ EXECSUFFIX;
	return if OS == "Windows" { temp +~ ".exe"; } else { temp; };
}

/**
 * Generates the true library name for the given base name.
 * @param name  The base name of the library.
 * @return      The true name of the library, including prefix and extension.
 */
fn lib_name(name: str) -> str
{
	ext: str = if OS == "Windows" { ".lib"; } else { ".a"; };
	return "lib" +~ name +~ ext;
}

BC_BIN: str = exe_name("bc");
DC_BIN: str = exe_name("dc");
LIBRARY: str = lib_name("libbcl");

BC_MANPAGE: str = EXECPREFIX +~ "bc" +~ EXECSUFFIX +~ ".1";
DC_MANPAGE: str = EXECPREFIX +~ "dc" +~ EXECSUFFIX +~ ".1";
BCL_MANPAGE: str = "bcl.3";

BCL_HEADER: str = "bcl.h";
BCL_HEADER_PATH: str = path.join(src_dir, path.join("include", BCL_HEADER));
PC_FILE: str = "bcl.pc";

/**
 * Returns the string value of the define for a prompt default define for an
 * executable.
 * @param name  The base name of the executable.
 * @return      The string value of the compiler define for the prompt default.
 */
fn prompt(name: str) -> str
{
	opt: sym = sym(config[name +~ "/default_prompt"]);

	ret: str =
	if opt == @off
	{
		"0";
	}
	else if opt == @tty_mode
	{
		str(uint(bool(config[name +~ "/default_tty_mode"])));
	}
	else
	{
		"1";
	};

	return ret;
}

HEADERS: []str = find_src_ext("include", "h");

FORCE: bool = bool(config["force"]);

BUILD_MODE: sym = sym(config["build_mode"]);

BC_ENABLED: str = str(uint(BUILD_MODE == @both || BUILD_MODE == @bc));
DC_ENABLED: str = str(uint(BUILD_MODE == @both || BUILD_MODE == @dc));
LIBRARY_ENABLED: str = str(uint(BUILD_MODE == @library));

EXTRA_MATH_ENABLED: str = str(uint(bool(config["extra_math"])));

HISTORY: sym = sym(config["history"]);
HISTORY_ENABLED: str = str(uint(HISTORY != @none));
EDITLINE_ENABLED: str = str(uint(HISTORY == @editline));
READLINE_ENABLED: str = str(uint(HISTORY == @readline));

NLS_ENABLED: str =
if OS == "Windows" || BUILD_MODE == @library
{
	"0";
}
else
{
	str(uint(sym(config["locales"]) != @none));
};

BUILD_TYPE: str =
if EXTRA_MATH_ENABLED != "0" && HISTORY_ENABLED != "0" && NLS_ENABLED != "0"
{
	"A";
}
else
{
	t: str = if EXTRA_MATH_ENABLED != "0" { ""; } else { "E"; } +~
	         if HISTORY_ENABLED != "0" { ""; } else { "H"; } +~
	         if NLS_ENABLED != "0" { ""; } else { "N"; };

	t;
};

OPTIMIZE: str = str(config["optimization"]);

VALGRIND_ARGS: []str = @[
	"valgrind",
	"--error-exitcode=100",
	"--leak-check=full",
	"--show-leak-kinds=all",
	"--errors-for-leak-kinds=all",
	"--track-fds=yes",
	"--track-origins=yes",
];

// Get the compiler. The user might have set one at the command line.
CC: str = language.compiler;

// Set optimization to "0" if it is empty.
CFLAGS_OPT: str = if OPTIMIZE == "" { "0"; } else { OPTIMIZE; };

// Get the command-line option for defining a preprocessor variable.
DEFOPT: str = compiler_db["opt.define"];

// Get the command-line string for the optimization option for the compiler.
OPTOPT: str = compiler_db["opt.optimization"] +~ CFLAGS_OPT;

// Get the compiler option for the object file to output to.
OBJOUTOPT: str = compiler_db["opt.objout"];
EXEOUTOPT: str = compiler_db["opt.exeout"];

// Get the compiler option for outputting an object file rather than an
// executable.
OBJOPT: str = compiler_db["opt.obj"];

// Get the compiler option for setting an include directory.
INCOPT: str = compiler_db["opt.include"] +~ path.join(src_dir, "include");

COVERAGE_CFLAGS: []str =
if bool(config["coverage"])
{
	@[ "-fprofile-arcs", "-ftest-coverage", "-g", "-O0", DEFOPT +~ "NDEBUG" ];
};

MAINEXEC: str =
if BUILD_MODE == @both || BUILD_MODE == @bc || BUILD_MODE == @library
{
	BC_BIN;
}
else
{
	DC_BIN;
};

MAINEXEC_FLAGS: []str = @[ DEFOPT +~ "MAINEXEC=" +~ MAINEXEC ];

// XXX: Library needs these defines to be true.
BC_DEF: str = if LIBRARY_ENABLED == "0" { BC_ENABLED; } else { "1"; };
DC_DEF: str = if LIBRARY_ENABLED == "0" { DC_ENABLED; } else { "1"; };

CFLAGS1: []str = config_list["cflags"] +~ @[ OPTOPT, INCOPT ] +~
                 COVERAGE_CFLAGS +~ MAINEXEC_FLAGS;
CFLAGS2: []str = @[
	DEFOPT +~ "BC_ENABLED=" +~ BC_DEF,
	DEFOPT +~ "DC_ENABLED=" +~ DC_DEF,
	DEFOPT +~ "BUILD_TYPE=" +~ BUILD_TYPE,
	DEFOPT +~ "EXECPREFIX=" +~ str(config["execprefix"]),
	DEFOPT +~ "BC_NUM_KARATSUBA_LEN=" +~ str(num(config["karatsuba_len"])),
	DEFOPT +~ "BC_ENABLE_LIBRARY=" +~ LIBRARY_ENABLED,
	DEFOPT +~ "BC_ENABLE_NLS=" +~ NLS_ENABLED,
	DEFOPT +~ "BC_ENABLE_EXTRA_MATH=" +~ EXTRA_MATH_ENABLED,
	DEFOPT +~ "BC_ENABLE_HISTORY=" +~ HISTORY_ENABLED,
	DEFOPT +~ "BC_ENABLE_EDITLINE=" +~ EDITLINE_ENABLED,
	DEFOPT +~ "BC_ENABLE_READLINE=" +~ READLINE_ENABLED,
	DEFOPT +~ "BC_ENABLE_MEMCHECK=" +~ str(uint(bool(config["memcheck"]))),
	DEFOPT +~ "BC_ENABLE_AFL=" +~ str(uint(bool(config["afl"]))),
	DEFOPT +~ "BC_ENABLE_OSSFUZZ=" +~ str(uint(bool(config["ossfuzz"]))),
	DEFOPT +~ "BC_DEFAULT_BANNER=" +~
	    str(uint(bool(config["bc/default_banner"]))),
	DEFOPT +~ "BC_DEFAULT_SIGINT_RESET=" +~
	    str(uint(bool(config["bc/default_sigint_reset"]))),
	DEFOPT +~ "BC_DEFAULT_TTY_MODE=" +~
	    str(uint(bool(config["bc/default_tty_mode"]))),
	DEFOPT +~ "BC_DEFAULT_PROMPT=" +~ prompt("bc"),
	DEFOPT +~ "BC_DEFAULT_EXPR_EXIT=" +~
	    str(uint(bool(config["bc/default_expr_exit"]))),
	DEFOPT +~ "BC_DEFAULT_DIGIT_CLAMP=" +~
	    str(uint(bool(config["bc/default_digit_clamp"]))),
	DEFOPT +~ "DC_DEFAULT_SIGINT_RESET=" +~
	    str(uint(bool(config["dc/default_sigint_reset"]))),
	DEFOPT +~ "DC_DEFAULT_TTY_MODE=" +~
	    str(uint(bool(config["dc/default_tty_mode"]))),
	DEFOPT +~ "DC_DEFAULT_PROMPT=" +~ prompt("dc"),
	DEFOPT +~ "DC_DEFAULT_EXPR_EXIT=" +~
	    str(uint(bool(config["dc/default_expr_exit"]))),
	DEFOPT +~ "DC_DEFAULT_DIGIT_CLAMP=" +~
	    str(uint(bool(config["dc/default_digit_clamp"]))),
];
CFLAGS: []str = CFLAGS1 +~ CFLAGS2;

LDFLAGS: []str = config_list["ldflags"];

COMMON_C_FILES: []str = @[
	"src/data.c",
	"src/num.c",
	"src/rand.c",
	"src/vector.c",
	"src/vm.c",
];

EXEC_C_FILES: []str = @[
	"src/args.c",
	"src/file.c",
	"src/lang.c",
	"src/lex.c",
	"src/main.c",
	"src/opt.c",
	"src/parse.c",
	"src/program.c",
	"src/read.c",
];

BC_C_FILES: []str = @[
	"src/bc.c",
	"src/bc_lex.c",
	"src/bc_parse.c",
];

DC_C_FILES: []str = @[
	"src/dc.c",
	"src/dc_lex.c",
	"src/dc_parse.c",
];

HISTORY_C_FILES: []str = @[
	"src/history.c",
];

LIBRARY_C_FILES: []str = @[
	"src/library.c",
];

GEN_HEADER1: str =
    "// Copyright (c) 2018-2025 Gavin D. Howard and contributors.\n" +~
    "// Licensed under the 2-clause BSD license.\n" +~
    "// *** AUTOMATICALLY GENERATED FROM ";
GEN_HEADER2: str = ". DO NOT MODIFY. ***\n\n";

GEN_LABEL1: str = "const char *";
GEN_LABEL2: str = " = \"";
GEN_LABEL3: str = "\";\n\n";
GEN_NAME1: str = "const char ";
GEN_NAME2: str = "[] = {\n";

GEN_LABEL_EXTERN1: str = "extern const char *";
GEN_LABEL_EXTERN2: str = ";\n\n";
GEN_NAME_EXTERN1: str = "extern const char ";
GEN_NAME_EXTERN2: str = "[];\n\n";

GEN_IFDEF1: str = "#if ";
GEN_IFDEF2: str = "\n";
GEN_ENDIF1: str = "#endif // ";
GEN_ENDIF2: str = "\n";

GEN_EX_START: str = "{{ A H N HN }}";
GEN_EX_END: str = "{{ end }}";

/// This is the max width to print characters to strgen files. This is to ensure
/// that lines don't go much over 80 characters.
MAX_WIDTH: usize = usize(72);

/**
 * A function to generate a C file that contains a C character array with the
 * contents of a text file. For more detail, see the `gen/strgen.c` program;
 * this function is exactly equivalent to that or should be.
 * @param input        The input file name.
 * @param output       The output file name.
 * @param exclude      True if extra math stuff should be excluded, false if
 *                     they should be included.
 * @param name         The name of the array.
 * @param label        If not equal to "", this is the label for the array,
 *                     which is essentially the "file name" in `bc` and `dc`.
 * @param define       If not equal to "", this is the preprocessor define
 *                     expression that should be used to guard the array with a
 *                     `#if`/`#endif` combo.
 * @param remove_tabs  True if tabs should be ignored, false if they should be
 *                     included.
 */
fn strgen(
	input: str,
	output: str,
	exclude: bool,
	name: str,
	label: str,
	def: str,
	remove_tabs: bool,
) -> void
{
	in: str = io.read_file(input);

	io.open(output, "w"): f
	{
		f.print(GEN_HEADER1 +~ input +~ GEN_HEADER2);

		if label != ""
		{
			f.print(GEN_LABEL_EXTERN1 +~ label +~ GEN_LABEL_EXTERN2);
		}

		f.print(GEN_NAME_EXTERN1 +~ name +~ GEN_NAME_EXTERN2);

		if def != ""
		{
			f.print(GEN_IFDEF1 +~ def +~ GEN_IFDEF2);
		}

		if label != ""
		{
			f.print(GEN_LABEL1 +~ label +~ GEN_LABEL2 +~ name +~ GEN_LABEL3);
		}

		f.print(GEN_NAME1 +~ name +~ GEN_NAME2);

		i: !usize = usize(0);
		count: !usize = usize(0);
		slashes: !usize = usize(0);

		// This is where the end of the license comment is found.
		while slashes < 2 && in[i] > 0
		{
			if slashes == 1 && in[i] == '*' && in[i + 1] == '/' &&
			   (in[i + 2] == '\n' || in[i + 2] == '\r')
			{
				slashes! = slashes + usize(1);
				i! = i + usize(2);
			}
			else if slashes == 0 && in[i] == '/' && in[i + 1] == '*'
			{
				slashes! = slashes + usize(1);
				i! = i + usize(1);
			}

			i! = i + usize(1);
		}

		// The file is invalid if the end of the license comment could not be
		// found.
		if i == in.len
		{
			error("Could not find end of license comment");
		}

		i! = i + usize(1);

		// Do not put extra newlines at the beginning of the char array.
		while in[i] == '\n' || in[i] == '\r'
		{
			i! = i + usize(1);
		}

		// This loop is what generates the actual char array. It counts how many
		// chars it has printed per line in order to insert newlines at
		// appropriate places. It also skips tabs if they should be removed.
		while i < in.len
		{
			if in[i] == '\r'
			{
				i! = i + usize(1);
				continue;
			}

			// If we should output the character, i.e., it is not a tab or we
			// can remove tabs...
			if !remove_tabs || in[i] != '\t'
			{
				// Check for excluding something for extra math.
				if in[i] == '{'
				{
					if in.slice(i, i + GEN_EX_START.len) == GEN_EX_START
					{
						if exclude
						{
							// Get past the braces.
							i! = i + usize(2);

							// Find the end of the end.
							while in[i] != '{' &&
							      in.slice(i, GEN_EX_END.len) != GEN_EX_END
							{
								i! = i + usize(1);
							}

							i! = i + GEN_EX_END.len;

							// Skip the last newline.
							if in[i] == '\r'
							{
								i! = i + usize(1);
							}

							i! = i + usize(1);

							continue;
						}
					}
					else if !exclude &&
					        in.slice(i, i + GEN_EX_END.len) == GEN_EX_END
					{
						i! = i + GEN_EX_END.len;

						// Skip the last newline.
						if in[i] == '\r'
						{
							i! = i + usize(1);
						}

						i! = i + usize(1);

						continue;
					}
				}

				// Print a tab if we are at the beginning of a line.
				if count == 0
				{
					f.print("\t");
				}

				val: str = str(in[i]) +~ ",";

				// Print the character.
				f.print(val);

				// Adjust the count.
				count! = count + val.len;

				if count > MAX_WIDTH
				{
					count! = usize(0);
					f.print("\n");
				}
			}

			i! = i + usize(1);
		}

		// Make sure the end looks nice.
		if count == 0
		{
			f.print("  ");
		}

		// Insert the NUL byte at the end.
		f.print("0\n};\n");

		if def != ""
		{
			f.print(GEN_ENDIF1 +~ def +~ GEN_ENDIF2);
		}
	}
}

/**
 * Creates a target to generate an object file from the given C file and returns
 * the target name of the new target.
 * @param c_file  The name of the C file target.
 * @return        The name of the object file target.
 */
fn c2o(c_file: str) -> str
{
	o_file: str = c_file +~ (if OS == "Windows" { ".obj"; } else { ".o"; });

	target o_file: c_file, HEADERS
	{
		$ $CC %(config_list["other_cflags"]) %(CFLAGS) $OBJOPT $OBJOUTOPT @(tgt)
		  @(file_dep);
	}

	return o_file;
}

/**
 * Generates a target to turn a text file into a C file with the text file's
 * contents as a char array, then generates a target to generate an object file
 * from that C file, then returns the name of the object file target.
 * @param txt_file     The name of the text file.
 * @param name         The name of the char array in the C file.
 * @param label        The label for the array, if any. (See the @a strgen()
 *                     function for more information.)
 * @param def          The preprocessor define(s) to guard the array, if any.
 *                     (See the @a strgen() function for more information.)
 * @param remove_tabs  True if tabs should be ignored, false otherwise. (See the
 *                     @a strgen() function for more information.)
 * @return             The name of the object file target.
 */
fn txt2o(
	txt_file: str,
	name: str,
	label: str,
	def: str,
	remove_tabs: bool,
) -> str
{
	c_file: str = txt_file +~ ".c";

	c_config: Gaml = @(gaml){
		strgen_name: $name
		strgen_label: $label
		strgen_define: $def
		strgen_remove_tabs: $remove_tabs
	};

	push c_config: config_stack
	{
		target c_file: txt_file
		{
			strgen(file_dep, tgt, EXTRA_MATH_ENABLED == "0",
			       str(config["strgen_name"]), str(config["strgen_label"]),
			       str(config["strgen_define"]),
			       bool(config["strgen_remove_tabs"]));
		}
	}

	return c2o(c_file);
}

/**
 * Generates a target for an executable and returns its name.
 * @param name     The name of the executable.
 * @param o_files  The object files for the executable.
 * @return         The name of the generated target.
 */
fn exe(name: str, o_files: []str) -> void
{
	target name: o_files
	{
		$ $CC %(config_list["other_cflags"]) %(CFLAGS) %(LDFLAGS) $EXEOUTOPT
		  @(tgt) %(file_deps);
	}
}

/**
 * Generates a target for a link.
 * @param name  The name of the link.
 * @param exec  The name of the executable target.
 */
fn ln(name: str, exec: str) -> void
{
	if OS == "Windows"
	{
		target name: exec
		{
			$ copy /v /y /b @(file_dep) @(tgt);
		}
	}
	else
	{
		target name: exec
		{
			$ ln -fs @("./" +~ path.basename(file_dep)) @(tgt);
		}
	}
}

/**
 * Generates a target for a library.
 * @param name  The name of the library.
 * @param exec  The name of the executable target.
 */
fn lib(name: str, o_files: []str) -> void
{
	if OS == "WINDOWS"
	{
		exe(name, o_files);
	}
	else
	{
		target name: o_files
		{
			$ ar -r -cu @(tgt) %(file_deps);
		}
	}
}

/**
 * Generates all of the test targets for an executable.
 * @param name  The base name of the executable.
 * @param targets  The targets that tests should depend on.
 */
fn exe_tests(name: str) -> void
{
	// XXX: Must always unset these so that the tests run correctly.
	env.unset "BC_ENV_ARGS", "BC_LINE_LENGTH", "DC_ENV_ARGS",
	          "DC_LINE_LENGTH"
	{
		bin: str = exe_name(name);

		testdir: str = path.join("tests", name);
		src_testdir: str = path.join(src_dir, testdir);
		all_file: str = path.join(src_testdir, "all.txt");
		tests: []str = io.read_file(all_file).split("\n");

		halt: str = if name == "bc" { "halt"; } else { "q"; };
		gen_options: []str = if name == "bc" { @[ "-lq" ]; };
		options: []str = if name == "bc" { @[ "-lqc" ]; } else { @[ "-xc" ]; };
		var: str = name.toupper() +~ "_LINE_LENGTH";

		args: []str =
		if bool(config["valgrind"])
		{
			VALGRIND_ARGS +~ @[ "./" +~ bin ];
		}
		else
		{
			@[ "./" +~ bin ];
		};

		test_config: Gaml = @(gaml){
			args: $args
			halt: $halt
			gen_options: $gen_options
			options: $options
			var: $var
		};

		push test_config: config_stack
		{
			for t: tests
			{
				if t == ""
				{
					continue;
				}

				test sym(path.join(testdir, t)): bin
				{
					test_file: str = tgt_name +~ ".txt";
					test_result_file: str = tgt_name +~ "_results.txt";

					path.mkdirp(path.dirname(test_result_file));

					$ %(config_list["args"]) %(config_list["options"])
					  @(path.join(src_dir, test_file)) > $test_result_file;

					exp_path: str = path.join(src_dir, test_result_file);
					exp := io.read_file_bytes(exp_path);
					actual := io.read_file_bytes(test_result_file);

					if exp != actual
					{
						error("Test \"" +~ tgt_name +~ "\" failed");
					}
				}
			}
		}
	}
}

/**
 * Gets the `$BINDIR`, including the `$DESTDIR`. This generates the default
 * value if it wasn't set.
 * @return  The `$BINDIR`, with the `$DESTDIR`.
 */
fn get_bindir() -> str
{
	temp: str = str(config["bindir"]);

	bindir: str =
	if temp == ""
	{
		path.join(str(config["prefix"]), "bin");
	}
	else
	{
		temp;
	};

	return path.join(DESTDIR, bindir);
}

/**
 * Gets the `$LIBDIR`, including the `$DESTDIR`. This generates the default
 * value if it wasn't set.
 * @return  The `$LIBDIR`, with the `$DESTDIR`.
 */
fn get_libdir() -> str
{
	temp: str = str(config["libdir"]);

	libdir: str =
	if temp == ""
	{
		path.join(str(config["prefix"]), "lib");
	}
	else
	{
		temp;
	};

	return path.join(DESTDIR, libdir);
}

/**
 * Gets the `$INCLUDEDIR`, including the `$DESTDIR`. This generates the default
 * value if it wasn't set.
 * @return  The `$INCLUDEDIR`, with the `$DESTDIR`.
 */
fn get_includedir() -> str
{
	temp: str = str(config["includedir"]);

	includedir: str =
	if temp == ""
	{
		path.join(str(config["prefix"]), "include");
	}
	else
	{
		temp;
	};

	return path.join(DESTDIR, includedir);
}

/**
 * Gets the `$PC_PATH`, including the `$DESTDIR`. This generates the default
 * value if it wasn't set.
 * @return  The `$PC_PATH`, with the `$DESTDIR`.
 */
fn get_pc_path() -> str
{
	pc_path: str =
	if str(config["pc_path"]) == ""
	{
		res := $ pkg-config --variable=pc_path pkg-config;

		str(res.stdout);
	}
	else
	{
		str(config["pc_path"]);
	};

	return path.join(DESTDIR, pc_path);
}

/**
 * Gets the `$DATAROOTDIR`, including the `$DESTDIR`. This generates the default
 * value if it wasn't set.
 * @return  The `$DATAROOTDIR`, with the `$DESTDIR`.
 */
fn get_datarootdir() -> str
{
	temp: str = str(config["datarootdir"]);

	datarootdir: str =
	if temp == ""
	{
		path.join(str(config["prefix"]), "share");
	}
	else
	{
		temp;
	};

	return path.join(DESTDIR, datarootdir);
}

/**
 * Gets the `$DATADIR`, including the `$DESTDIR`. This generates the default
 * value if it wasn't set.
 * @return  The `$DATADIR`, with the `$DESTDIR`.
 */
fn get_datadir() -> str
{
	temp: str = str(config["datadir"]);

	datadir: str =
	if temp == ""
	{
		get_datarootdir();
	}
	else
	{
		temp;
	};

	return path.join(DESTDIR, datadir);
}

/**
 * Gets the `$MANDIR`, including the `$DESTDIR`. This generates the default
 * value if it wasn't set.
 * @return  The `$MANDIR`, with the `$DESTDIR`.
 */
fn get_mandir() -> str
{
	temp: str = str(config["mandir"]);

	mandir: str =
	if temp == ""
	{
		path.join(get_datadir(), "man");
	}
	else
	{
		temp;
	};

	return path.join(DESTDIR, mandir);
}

/**
 * Gets the `$MAN1DIR`, including the `$DESTDIR`. This generates the default
 * value if it wasn't set.
 * @return  The `$MAN1DIR`, with the `$DESTDIR`.
 */
fn get_man1dir() -> str
{
	temp: str = str(config["man1dir"]);

	man1dir: str =
	if temp == ""
	{
		path.join(get_mandir(), "man1");
	}
	else
	{
		temp;
	};

	return path.join(DESTDIR, man1dir);
}

/**
 * Gets the `$MAN3DIR`, including the `$DESTDIR`. This generates the default
 * value if it wasn't set.
 * @return  The `$MAN3DIR`, with the `$DESTDIR`.
 */
fn get_man3dir() -> str
{
	temp: str = str(config["man3dir"]);

	man3dir: str =
	if temp == ""
	{
		path.join(get_mandir(), "man3");
	}
	else
	{
		temp;
	};

	return path.join(DESTDIR, man3dir);
}
